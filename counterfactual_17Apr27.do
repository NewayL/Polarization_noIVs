* This do file run the regression specification in Yawen's "Does Trade Liberalization Induce Occupational Movement?"
* and then compute the conterfacural as if there were no trade opening
* The regression part is from "regressionsYawen_15Oct28.do"
* After the regression, get the predicted values with and without the trade shock 

* This do file modifies counterfactual_15Dec18.do, to correct the mistake of excluding residual in the counterfactual 
* analysis
* This do file follows "counterfactual_17Mar16.do", but use control function approach to solve for endogeneity problem


* input data are generated by "regressionsYawen_15Oct28.do"

* Last updated: Apr 27th,2017


*To run the control function regression, need to perform two steps:
* 1. regress local task shocks on local tariffs, get residuals (3 tasks, 3 regressions)
* 2. include the residuals obtained in the first stage in the regression of 
*	 local relative employment and local trade tasks

set more off
cap cd "C:/PhD Study/Year 3/Projects/Job Porlarization/Arranged Files"
cap cd "/Users/yawenliang/Dropbox/My_Work/polarization/"

clear

use "data/temp/regression_Oct28.dta",clear /* generated by "regressionsYawen_15Oct28.do" */

* group 1: male skilled 
* group 2: male unskilled
* group 3: female skilled
* group 4: female unskilled


foreach task in a r m{
ren delta_`task'_kab delta_`task'
replace delta_`task'=delta_`task'*100
}

foreach task in a r m{
gen delta_`task'XdlnnxWLD_`task'_kab = delta_`task'*dlnnxWLD_`task'_kab
gen delta_fullXdlnnxWLD_`task'_kab = delta_a*delta_r*delta_m*dlnnxWLD_`task'_kab
gen LmanualXdelta_`task'XdlnnxWLD_`task'_kab = Lmanual_shr_kab*delta_`task'XdlnnxWLD_`task'_kab
gen LabstractXdelta_`task'XdlnnxWLD_`task'_kab = Labstract_shr_kab*delta_`task'XdlnnxWLD_`task'_kab
}


foreach item in a r m{
foreach num of numlist 1/4{
gen delta_`item'Xdlngp`num' = delta_`item'*dlngrp`num'_kab
}
}

foreach num of numlist 1/4{
gen LmanualXdlngp`num' = Lmanual_shr_kab*dlngrp`num'
gen LabstractXdlngp`num' = Labstract_shr_kab*dlngrp`num'
}

set more off
****1. Short periods
global delta delta_a delta_r delta_m

* regressor set 1 (change in log)
global dlnx dlngrp*_kab
global deltaXdlnx delta_*dlngp*
global dlnnxWLD dlnnxWLD_a_kab dlnnxWLD_r_kab dlnnxWLD_m_kab
global deltaXdlnnxWLD delta_aXdlnnxWLD_a_kab delta_rXdlnnxWLD_r_kab delta_mXdlnnxWLD_m_kab
global deltaXdlnnxWLD_full delta_fullXdlnnxWLD_a_kab delta_fullXdlnnxWLD_r_kab delta_fullXdlnnxWLD_m_kab 

* pick the regressor set
global Y1 dlnY1 /* options: dlnY1 pctdY1 */
global Y2 dlnY2 /* options: dlnY2 pctdY2 */
 
global X1 $dlnnxWLD /* options: $dlnYwtnxWLD $pctdYwtnxWLD */
global X2 $deltaXdlnnxWLD /* options: $deltaXdlnYwtnxWLD $deltaXpctdYwtnxWLD */
global cX2 c.delta_aXdlnnxWLD_a_kab c.delta_rXdlnnxWLD_r_kab c.delta_mXdlnnxWLD_m_kab
global X3 $deltaXdlnnxWLD_full /* options: $deltaXdlnYwtnxWLD_full $$deltaXpctdYwtnxWLD_full */

global X4 $dlnx /* options: $dlnx $pctdx */
global X5 $deltaXdlnx /* options: $deltaXdlnx $deltaXpctdx */
global X6 Lmanual_shr_kab
global X7 Labstract_shr_kab
global X8 LmanualXdelta_*XdlnnxWLD_*_kab
global X9 LabstractXdelta_*XdlnnxWLD_*_kab
duplicates tag code1990 grp,gen(dup)
keep if dup==1


* use distance to port, distance to airport, port dummies and related interactions to instrument the three shocks
merge m:1 code1990 using "data/output/distances_code1990.do"
drop if _merge==2

foreach task in a r m{
gen delta_`task'Xdist_port = delta_`task'*cdist_port
gen delta_`task'Xdist_airport = delta_`task'*cdist_airport
gen delta_`task'Xdport = delta_`task'*dport
gen delta_`task'Xdaport = delta_`task'*daport
gen delta_`task'Xdlntariff_`task'_kab = delta_`task'*dlntariff_`task'_kab
gen delta_fullXdlntariff_`task'_kab = delta_a*delta_r*delta_m*dlntariff_`task'_kab
}

*IV set 

global IV1 dlntariff_a_kab dlntariff_r_kab dlntariff_m_kab
global IV2 cdist_port cdist_airport dport daport

global deltaIV1 delta_aXdlntariff_a_kab delta_rXdlntariff_r_kab delta_mXdlntariff_m_kab
global deltaIV2 delta_fullXdlntariff_a_kab delta_fullXdlntariff_r_kab delta_fullXdlntariff_m_kab
global deltaIV3 cdist_port cdist_airport dport daport


levelsof year, local(yr)
bys year: sum $deltaXdlnnxWLD


* REGRESSIONS (No sample consideration)
********************************************************************************************

* 1. OLS approach

foreach pd in `yr'{
reg $Y1 $X2 $X3 $X4 $X5 i.prov i.grp if year==`pd', cluster(code1990)
predict Y1_hat_OLS`pd'
if `pd'==1996{
outreg2 using "results/Apr27_17/table1",se coefastr bdec(3) tex nolabel keep($X2 $X3 $X4 $X5 $X6) addtext(Period, `pd', method, OLS) replace
}
else{
outreg2 using "results/Apr27_17/table1",se coefastr bdec(3) tex nolabel keep($X2 $X3 $X4 $X5 $X6) addtext(Period, `pd', method, OLS) append
}

reg $Y2 $X2 $X3 $X4 $X5 i.prov i.grp if year==`pd', cluster(code1990)
predict Y2_hat_OLS`pd'
outreg2 using "results/Apr27_17/table1",se coefastr bdec(3) tex nolabel keep($X2 $X3 $X4 $X5 $X7) addtext(Period, `pd', method, OLS) append
}



* 2. Control function approach
***********
* Stage 1:
levelsof year, local(yr)

foreach pd in `yr'{
reg dlnnxWLD_a_kab $IV1 $X3 $X4 $X5  i.prov i.grp if year==`pd', cluster(code1990)
outreg2 using "results/Apr27_17/table1_2`pd'",se coefastr bdec(3) tex nolabel keep($IV1) addtext(Period, `pd') replace
predict ctrfn_a1_`pd',r

reg dlnnxWLD_r_kab $IV1 $X3 $X4 $X5  i.prov i.grp if year==`pd', cluster(code1990)
outreg2 using "results/Apr27_17/table1_2`pd'",se coefastr bdec(3) tex nolabel keep($IV1) addtext(Period, `pd')  append
predict ctrfn_r1_`pd',r

reg dlnnxWLD_m_kab $IV1 $X3 $X4 $X5  i.prov i.grp if year==`pd', cluster(code1990)
outreg2 using "results/Apr27_17/table1_2`pd'",se coefastr bdec(3) tex nolabel keep($IV1) addtext(Period, `pd')  append
predict ctrfn_m1_`pd',r

reg dlnnxWLD_a_kab $IV1 $X3 $X4 $X5 i.prov i.grp if year==`pd'
outreg2 using "results/Apr27_17/table1_3`pd'",se coefastr bdec(3) tex nolabel keep($IV1) addtext(Period, `pd') replace
predict ctrfn_a2_`pd',r

reg dlnnxWLD_r_kab $IV1 $X3 $X4 $X5 i.prov i.grp if year==`pd'
outreg2 using "results/Apr27_17/table1_3`pd'",se coefastr bdec(3) tex nolabel keep($IV1) addtext(Period, `pd') append
predict ctrfn_r2_`pd',r

reg dlnnxWLD_m_kab $IV1 $X3 $X4 $X5 i.prov i.grp if year==`pd'
outreg2 using "results/Apr27_17/table1_3`pd'",se coefastr bdec(3) tex nolabel keep($IV1) addtext(Period, `pd') append
predict ctrfn_m2_`pd',r
}

foreach pd in `yr'{
foreach task in a r m{
gen ctrfn_`task'1_`pd'2 = ctrfn_`task'1_`pd'*ctrfn_`task'1_`pd'
gen ctrfn_`task'1_`pd'3 = ctrfn_`task'1_`pd'*ctrfn_`task'1_`pd'*ctrfn_`task'1_`pd'
gen ctrfn_`task'2_`pd'2 = ctrfn_`task'2_`pd'*ctrfn_`task'2_`pd'
gen ctrfn_`task'2_`pd'3 = ctrfn_`task'2_`pd'*ctrfn_`task'2_`pd'*ctrfn_`task'1_`pd'
}
}

foreach task in a r m{
foreach pd in `yr'{
gen delta_`task'Xctrfn_`task'1_`pd' = delta_`task'*ctrfn_`task'1_`pd'
gen delta_`task'Xctrfn_`task'2_`pd' = delta_`task'*ctrfn_`task'2_`pd'
gen delta_fullXctrfn_`task'1_`pd' = delta_a*delta_r*delta_m*ctrfn_`task'1_`pd'
gen delta_fullXctrfn_`task'2_`pd' = delta_a*delta_r*delta_m*ctrfn_`task'2_`pd'
}
}

global ctrfn1_1996 ctrfn_a1_1996 ctrfn_r1_1996 ctrfn_m1_1996
global ctrfn2_1996 ctrfn_a2_1996 ctrfn_r2_1996 ctrfn_m2_1996
global ctrfn1_2006 ctrfn_a1_2006 ctrfn_r1_2006 ctrfn_m1_2006
global ctrfn2_2006 ctrfn_a2_2006 ctrfn_r2_2006 ctrfn_m2_2006

************
* Stage 2:
foreach pd in `yr'{
reg $Y1 $X2 $X3 $X4 $X5  ${ctrfn1_`pd'} i.prov i.grp if year==`pd', cluster(code1990)

if `pd'==1996{
outreg2 using "results/Apr27_17/table2",se coefastr bdec(3) tex nolabel keep($X2 $X3 $X4 $X5 $X6) addtext(Period, `pd', method, ctrfn) replace
}
else{
outreg2 using "results/Apr27_17/table2",se coefastr bdec(3) tex nolabel keep($X2 $X3 $X4 $X5 $X6) addtext(Period, `pd', method, ctrfn) append
}

reg $Y2 $X2 $X3 $X4 $X5  ${ctrfn2_`pd'} i.prov i.grp if year==`pd', cluster(code1990)
outreg2 using "results/Apr27_17/table2",se coefastr bdec(3) tex nolabel keep($X2 $X3 $X4 $X5 $X7) addtext(Period, `pd', method, ctrfn) append
}


***********************
* Sample

foreach pd in `yr'{
gen sample1_OLS`pd' = 0
gen sample2_OLS`pd' = 0
replace sample1_OLS`pd' = 1 if Y1_hat_OLS`pd'!=. & $Y1!=.
replace sample2_OLS`pd' = 1 if Y2_hat_OLS`pd'!=. & $Y2!=.

gen sample1_CF`pd' = 0
gen sample2_CF`pd' = 0
replace sample1_CF`pd' = 1 if ctrfn_a1_`pd'!=. & ctrfn_r1_`pd'!=. & ctrfn_m1_`pd'!=. & sample1_OLS`pd'==1
replace sample2_CF`pd' = 1 if ctrfn_a2_`pd'!=. & ctrfn_r2_`pd'!=. & ctrfn_m2_`pd'!=. & sample2_OLS`pd'==1
}


tab sample1_CF2006 sample1_OLS2006 if year==2006
tab sample2_CF2006 sample2_OLS2006 if year==2006

drop Y*_hat*


* COUNTERFACTUAL
*******************************************************************************

* 1. OLS Counterfactual

foreach pd in `yr'{
reg $Y1 $X2 $X3 $X4 $X5  i.prov i.grp if year==`pd', cluster(code1990)
predict eOLS_dlnY1_hat`pd' if year==`pd',r

foreach task in a r m{
gen temp`task' = delta_`task'XdlnnxWLD_`task'_kab
gen temp`task'_full = delta_fullXdlnnxWLD_`task'_kab
replace delta_`task'XdlnnxWLD_`task'_kab=0 if temp`task'!=.
replace delta_fullXdlnnxWLD_`task'_kab=0 if temp`task'_full!=.
}
predict dlnY1OLS_hat`pd'_ctf if year==`pd'

foreach task in a r m{
replace delta_`task'XdlnnxWLD_`task'_kab = temp`task'
replace delta_fullXdlnnxWLD_`task'_kab = temp`task'_full
}

drop temp*
}



foreach pd in `yr'{
reg $Y2 $X2 $X3 $X4 $X5  i.prov i.grp if year==`pd', cluster(code1990)
predict eOLS_dlnY2_hat`pd' if year==`pd',r

foreach task in a r m{
gen temp`task' = delta_`task'XdlnnxWLD_`task'_kab
gen temp`task'_full = delta_fullXdlnnxWLD_`task'_kab
replace delta_`task'XdlnnxWLD_`task'_kab=0 if temp`task'!=.
replace delta_fullXdlnnxWLD_`task'_kab=0 if temp`task'_full!=.
}
predict dlnY2OLS_hat`pd'_ctf if year==`pd'

foreach task in a r m{
replace delta_`task'XdlnnxWLD_`task'_kab = temp`task' 
replace delta_fullXdlnnxWLD_`task'_kab = temp`task'_full
}

drop temp*
}


* 2. Control Function Counterfactual


************************
foreach pd in `yr'{

* make the sample same as the OLS sample:
*foreach task in a r m{
*replace ctrfn_`task'1_`pd'=0 if ctrfn_`task'1_`pd'==. & sample1_OLS`pd' == 1 /* 4 observations changed */
*}

quietly:  reg $Y1 $X2 $X3 $X4 $X5  ${ctrfn1_`pd'} i.prov i.grp if year==`pd', cluster(code1990)
predict eCF_dlnY1_hat`pd' if year==`pd',r
if `pd'==1996{
outreg2 using "results/Apr27_17/table3",se coefastr bdec(3) tex nolabel keep($X2 $X3 $X4 $X5 $X6) addtext(Period, `pd', method, ctrfn) replace
}
else{
outreg2 using "results/Apr27_17/table3",se coefastr bdec(3) tex nolabel keep($X2 $X3 $X4 $X5 $X6) addtext(Period, `pd', method, ctrfn) append
}

foreach task in a r m{
gen temp`task' = delta_`task'XdlnnxWLD_`task'_kab
gen temp`task'_full = delta_fullXdlnnxWLD_`task'_kab
replace delta_`task'XdlnnxWLD_`task'_kab=0 if temp`task'!=.
replace delta_fullXdlnnxWLD_`task'_kab=0 if temp`task'_full!=.
}
predict dlnY1CF_hat`pd'_ctf if year==`pd'

foreach task in a r m{
replace delta_`task'XdlnnxWLD_`task'_kab = temp`task'
replace delta_fullXdlnnxWLD_`task'_kab = temp`task'_full
}

* make the sample same as the OLS sample:
*foreach task in a r m{
*replace eCF_dlnY1_hat`pd'=eOLS_dlnY1_hat`pd' if ctrfn_`task'1_`pd'==. & sample1_OLS`pd' == 1
*replace dlnY1CF_hat`pd'_ctf = dlnY1OLS_hat`pd'_ctf if ctrfn_`task'1_`pd'==. & sample1_OLS`pd' == 1
*}

drop temp*
}


foreach pd in `yr'{
* make the sample same as the OLS sample:
*foreach task in a r m{
*replace ctrfn_`task'2_`pd'=0 if  ctrfn_`task'2_`pd'==. & sample2_OLS`pd' == 1 /* 3 observations changed */
*}
quietly: reg $Y2 $X2 $X3 $X4 $X5  ${ctrfn2_`pd'} i.prov i.grp if year==`pd', cluster(code1990)
outreg2 using "results/Apr27_17/table3",se coefastr bdec(3) tex nolabel keep($X2 $X3 $X4 $X5 $X7) addtext(Period, `pd', method, ctrfn) append
predict eCF_dlnY2_hat`pd' if year==`pd',r

foreach task in a r m{
gen temp`task' = delta_`task'XdlnnxWLD_`task'_kab
gen temp`task'_full = delta_fullXdlnnxWLD_`task'_kab
replace delta_`task'XdlnnxWLD_`task'_kab=0 if temp`task'!=.
replace delta_fullXdlnnxWLD_`task'_kab=0 if temp`task'_full!=.
}
predict dlnY2CF_hat`pd'_ctf if year==`pd'

foreach task in a r m{
replace delta_`task'XdlnnxWLD_`task'_kab = temp`task' 
replace delta_fullXdlnnxWLD_`task'_kab = temp`task'_full
}

* make the sample same as the OLS sample:
*foreach task in a r m{
*replace eCF_dlnY2_hat`pd'=eOLS_dlnY2_hat`pd' if ctrfn_`task'2_`pd'==. & sample2_OLS`pd' == 1
*replace dlnY2CF_hat`pd'_ctf = dlnY2OLS_hat`pd'_ctf if ctrfn_`task'2_`pd'==. & sample2_OLS`pd' == 1
*}

drop temp*
}


************************
* Choose which method to use to compute the counterfactual: OLS or CF
foreach pd in `yr'{
gen e_dlnY1_hat`pd' = eCF_dlnY1_hat`pd'
gen dlnY1_hat`pd'_ctf  = dlnY1CF_hat`pd'_ctf 
gen e_dlnY2_hat`pd' = eCF_dlnY2_hat`pd'
gen dlnY2_hat`pd'_ctf = dlnY2CF_hat`pd'_ctf 
}


************************

foreach Y in Y1 Y2{
gen dln`Y'_ctf = .
replace dln`Y'_ctf = dln`Y'_hat1996_ctf+e_dln`Y'_hat1996 if year==1996
replace dln`Y'_ctf = dln`Y'_hat2006_ctf+e_dln`Y'_hat2006 if year==2006
gen dln`Y'_trade = dln`Y'-dln`Y'_ctf
}

keep year code1990 grp id dlnY1 dlnY2 dlnY*_ctf dlnY*_trade LY1 LY2 Y1 Y2 L_kabgrp LL_kabgrp

save "data/temp/ctf_17Apr27.dta",replace

stop

use "data/temp/ctf_17Apr27.dta",clear

drop if dlnY1==.
drop if dlnY2==.
drop if dlnY1_ctf==.
drop if dlnY2_ctf==.


* compute the predictions using fitted values
foreach Y in Y1 Y2{
gen `Y'_ctf = (1+dln`Y'_ctf)*L`Y'
}

* L for "lagged"

gen mocc_shr = Y1/(Y1+Y2+Y1*Y2)
gen rocc_shr = (Y1*Y2)/(Y1+Y2+Y1*Y2)
gen cocc_shr = Y2/(Y1+Y2+Y1*Y2)

gen Lmocc_shr = LY1/(LY1+LY2+LY1*LY2)
gen Lrocc_shr = (LY1*LY2)/(LY1+LY2+LY1*LY2)
gen Lcocc_shr = LY2/(LY1+LY2+LY1*LY2)
 
foreach task in m r c{
gen d`task'occ_shr  = `task'occ_shr-L`task'occ_shr
}

* compute the docc_shr caused by trade
foreach item in ctf{
gen mocc_shr_`item' = Y1_`item'/(Y1_`item'+Y2_`item'+Y1_`item'*Y2_`item')
gen rocc_shr_`item' = (Y1_`item'*Y2_`item')/(Y1_`item'+Y2_`item'+Y1_`item'*Y2_`item')
gen cocc_shr_`item' = Y2_`item'/(Y1_`item'+Y2_`item'+Y1_`item'*Y2_`item')
}


foreach task in m r c{
gen d`task'occ_shr_ctf = `task'occ_shr_ctf-L`task'occ_shr
gen d`task'occ_shr_trade = d`task'occ_shr-d`task'occ_shr_ctf /* total - no trade */
}
gen n = 1

collapse (mean) d*occ_shr d*occ_shr_ctf d*occ_shr_trade (sum) n [aweight=L_kabgrp], by(year)



* GRAPH
********************************************************************************************
gen period = year
label define periodl 1 "1990-1996" 2 "2002-2006" 3 "1990-2006"
label values period periodl

* aggregated

graph bar dmocc_shr_trade drocc_shr_trade dcocc_shr_trade, over(period,label(labsize(small))) legend (label(1 "Manual Occupations" ) label(2 "Routine Occupations") ///
label(3 "Cognitive Occupations")) ytitle("Change in Employment Share", size(small))  ///
title("Trade Induced Change in Employment Shares by Occupation in Indonesia", size(medsmall)) name(docc_shr_trade,replace) 

* compare with the total change computed by "Pattern9006_15Oct26.do"

keep year d*occ_shr_trade
merge 1:1 year using "data/temp/pattern_Nov22.dta"

drop _merge
foreach task in m r c{
ren d`task'occ_shr d`task'occ_shr0
ren d`task'occ_shr_trade d`task'occ_shr1
gen d`task'occ_shr3 = d`task'occ_shr0-d`task'occ_shr1 /* domestic */
}

reshape long dmocc_shr drocc_shr dcocc_shr, i(year) j(aggregate)

label define aggregatel 0 "overall" 1 "trade induced"  3 "residual" 
label value aggregate "aggregatel"
keep if year==2006

graph bar dmocc_shr drocc_shr dcocc_shr, over(aggregate,label(labsize(small))) legend (label(1 "Manual Occupations" ) label(2 "Routine Occupations") ///
label(3 "Cognitive Occupations")) ytitle("Change in Employment Share", size(small))  ///
title("Change in Employment Shares by Occupation in Indonesia (2002-2006)", size(medsmall)) name(docc_shr_all,replace) scheme(vg_s2c) graphregion(fcolor(white) lcolor(white))

